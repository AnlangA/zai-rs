<!doctype html>
<html lang="zh-CN">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>AI Chat - æ™ºæ™®AIèŠå¤©åŠ©æ‰‹</title>
        <link rel="stylesheet" href="/static/style.css" />
        <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
        <link
            href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css"
            rel="stylesheet"
        />
        <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
        <script>
            // Ensure Prism Autoloader fetches languages from CDN reliably
            if (window.Prism && Prism.plugins && Prism.plugins.autoloader) {
                Prism.plugins.autoloader.languages_path =
                    'https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/';
            }
        </script>
    </head>
    <body>
        <div class="chat-container">
            <header class="chat-header">
                <div class="header-content">
                    <h1>ğŸ¤– AI Assistant</h1>
                    <div class="status-indicator">
                        <span class="status-dot online"></span>
                        <span class="status-text">åœ¨çº¿</span>
                    </div>
                </div>
            </header>

            <div class="chat-messages" id="chatMessages">
                <div class="message assistant-message">
                    <div class="message-avatar">
                        <div class="avatar ai-avatar">
                            <svg
                                width="20"
                                height="20"
                                viewBox="0 0 24 24"
                                fill="none"
                                stroke="currentColor"
                                stroke-width="2"
                            >
                                <path
                                    d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5z"
                                />
                                <path d="M9 12l2 2 4-4" />
                            </svg>
                        </div>
                    </div>
                    <div class="message-content">
                        <div class="message-text">
                            æ‚¨å¥½ï¼æˆ‘æ˜¯æ™ºæ™®AIåŠ©æ‰‹ï¼Œæœ‰ä»€ä¹ˆå¯ä»¥å¸®åŠ©æ‚¨çš„å—ï¼Ÿ
                        </div>
                        <div class="message-time">åˆšåˆš</div>
                    </div>
                </div>
            </div>

            <div class="chat-input-container">
                <div class="input-wrapper">
                    <textarea
                        id="messageInput"
                        class="message-input"
                        placeholder="è¾“å…¥æ‚¨çš„æ¶ˆæ¯..."
                        rows="1"
                    ></textarea>
                    <button id="thinkToggle" class="think-toggle" title="Think æ¨¡å¼ï¼šå…³é—­" aria-pressed="false">
                        <span class="brain">ğŸ§ </span>
                        <span class="label">Think</span>
                    </button>
                    <button id="sendButton" class="send-button">
                        <span class="send-icon">â¤</span>
                    </button>
                </div>
                <div class="input-footer">
                    <small class="input-hint"
                        >æŒ‰ Enter å‘é€ï¼ŒShift+Enter æ¢è¡Œ</small
                    >
                </div>
            </div>
        </div>

        <div
            class="typing-indicator"
            id="typingIndicator"
            style="display: none"
        >
            <div class="typing-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>
            <span>AI æ­£åœ¨æ€è€ƒ...</span>
        </div>

        <script>
            // é…ç½® marked.js
            marked.setOptions({
                highlight: function (code, lang) {
                    if (Prism.languages[lang]) {
                        try {
                            return Prism.highlight(
                                code,
                                Prism.languages[lang],
                                lang,
                            );
                        } catch (e) {
                            console.warn("Prism highlighting failed:", e);
                        }
                    }
                    return code;
                },
                breaks: true,
                gfm: true,
                tables: true,
                sanitize: false, // æˆ‘ä»¬ä½¿ç”¨ DOMPurify æ¥å¤„ç†å®‰å…¨æ€§
                smartLists: true,
                smartypants: true,
            });

            // è‡ªå®šä¹‰æ¸²æŸ“å™¨æ¥æ·»åŠ ä»£ç å—å¤åˆ¶æŒ‰é’®
            const renderer = new marked.Renderer();
            const originalCodeRenderer = renderer.code.bind(renderer);

            renderer.code = function (code, language) {
                const copyButton = `<button class="copy-button" onclick="copyCode(this)" title="å¤åˆ¶ä»£ç ">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                    </svg>
                </button>`;

                // é»˜è®¤è¯­è¨€ï¼Œé¿å…æ— è¯­è¨€æ—¶ä¸¢å¤±æ ·å¼ï¼ˆPrism ä¾èµ– language-*ï¼‰
                const lang = (typeof language === "string" && language.trim()) ? language.toLowerCase() : "plaintext";
                let codeHtml = originalCodeRenderer(code, lang);

                // ç¡®ä¿ <pre> å’Œ <code> è‡³å°‘æœ‰ä¸€ä¸ª language-* ç±»ï¼Œä¾¿äºæœ€ç»ˆé«˜äº®
                if (!/language-/.test(codeHtml)) {
                    codeHtml = codeHtml
                        .replace(/<pre(?![^>]*class=)/, `<pre class="language-${lang}"`)
                        .replace(/<code(?![^>]*class=)/, `<code class="language-${lang}"`);
                }
                return `<div class="code-block-container">${codeHtml}${copyButton}</div>`;
            };

            marked.use({ renderer });

            // å¤åˆ¶ä»£ç åŠŸèƒ½
            function copyCode(button) {
                const codeBlock = button.parentElement.querySelector("code");
                const text = codeBlock.textContent;

                navigator.clipboard
                    .writeText(text)
                    .then(() => {
                        const originalText = button.innerHTML;
                        button.innerHTML = `<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20 6 9 17 4 12"></polyline>
                    </svg>`;
                        button.classList.add("copied");

                        setTimeout(() => {
                            button.innerHTML = originalText;
                            button.classList.remove("copied");
                        }, 2000);
                    })
                    .catch((err) => {
                        console.error("å¤åˆ¶å¤±è´¥:", err);
                    });
            }

            // å…¨å±€å˜é‡
            let currentSessionId = null;
            let isStreaming = false;
            let currentStreamingElement = null;
            let thinkMode = JSON.parse(localStorage.getItem("thinkMode") || "false");
            // æ»šåŠ¨ä¸é«˜äº®æ§åˆ¶
            let prismTimeout = null;
            let autoStick = true;

            // Frame-batched streaming renderer with a blinking caret and partial highlight
            let streamRenderScheduled = false;
            const enablePartialHighlight = true;

            function ensureStreamContainers(rootEl) {
                if (!rootEl) return { stable: null, tail: null };
                let stable = rootEl.querySelector('.stable');
                let tail = rootEl.querySelector('.tail');
                if (!stable || !tail) {
                    rootEl.innerHTML = '<div class="stable"></div><div class="tail"><span class="typing-cursor">â–Œ</span></div>';
                    stable = rootEl.querySelector('.stable');
                    tail = rootEl.querySelector('.tail');
                }
                return { stable, tail };
            }

            function computeStableEnd(markdown) {
                // Find last balanced code fence ```
                const fenceRe = /```/g;
                let m, count = 0, lastPos = -1;
                while ((m = fenceRe.exec(markdown)) !== null) {
                    count++;
                    lastPos = m.index;
                }
                if (count % 2 === 0) return markdown.length;
                return lastPos >= 0 ? lastPos : 0;
            }

            function scheduleStreamRender() {
                if (streamRenderScheduled) return;
                streamRenderScheduled = true;
                requestAnimationFrame(() => {
                    streamRenderScheduled = false;
                    if (!currentStreamingElement || !currentStreamingElement.messageTextEl) return;
                    const el = currentStreamingElement.messageTextEl;
                    const { stable, tail } = ensureStreamContainers(el);
                    const raw = el.getAttribute('data-raw-text') || '';

                    if (!enablePartialHighlight) {
                        el.innerHTML = DOMPurify.sanitize(marked.parse(raw)) + '<span class="typing-cursor">â–Œ</span>';
                        scrollToBottom();
                        return;
                    }

                    const prevStableLen = parseInt(el.getAttribute('data-stable-len') || '0', 10);
                    const stableEnd = computeStableEnd(raw);

                    if (stableEnd !== prevStableLen && stable) {
                        const stableMd = raw.slice(0, stableEnd);
                        stable.innerHTML = DOMPurify.sanitize(marked.parse(stableMd));
                        try { Prism.highlightAllUnder(stable); } catch (_) {}
                        el.setAttribute('data-stable-len', String(stableEnd));
                    }

                    if (tail) {
                        const tailMd = raw.slice(stableEnd);
                        tail.innerHTML = DOMPurify.sanitize(marked.parse(tailMd)) + '<span class="typing-cursor">â–Œ</span>';
                    }

                    scrollToBottom();
                });
            }

            // DOM å…ƒç´ ç¼“å­˜
            const elements = {
                chatMessages: null,
                messageInput: null,
                sendButton: null,
                thinkToggle: null,
                typingIndicator: null,
            };

            // åˆå§‹åŒ–
            function initializeChat() {
                // ç¼“å­˜DOMå…ƒç´ 
                elements.chatMessages = document.getElementById("chatMessages");
                elements.messageInput = document.getElementById("messageInput");
                elements.sendButton = document.getElementById("sendButton");
                elements.thinkToggle = document.getElementById("thinkToggle");
                elements.typingIndicator =
                    document.getElementById("typingIndicator");

                // é‡ç½®çŠ¶æ€
                isStreaming = false;
                currentStreamingElement = null;

                // ä» localStorage æ¢å¤ä¼šè¯ID
                const savedSessionId = localStorage.getItem("chatSessionId");
                if (savedSessionId) {
                    currentSessionId = savedSessionId;
                }

                // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
                setupEventListeners();

                // åˆå§‹åŒ– Think æŒ‰é’® UI
                updateThinkToggleUI();

                // è°ƒæ•´è¾“å…¥æ¡†é«˜åº¦
                adjustInputHeight();
            }

            // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            function setupEventListeners() {
                // å‘é€æŒ‰é’®ç‚¹å‡»äº‹ä»¶
                elements.sendButton.addEventListener("click", function (event) {
                    if (elements.sendButton.disabled) {
                        event.preventDefault();
                        return;
                    }
                    sendMessage();
                });

                // Think æŒ‰é’®äº‹ä»¶
                if (elements.thinkToggle) {
                    elements.thinkToggle.addEventListener("click", toggleThinkMode);
                }

                // èŠå¤©åŒºåŸŸæ»šåŠ¨çŠ¶æ€ç›‘å¬ï¼ˆä»…åœ¨æ¥è¿‘åº•éƒ¨æ—¶æ‰è‡ªåŠ¨è·Ÿéšï¼‰
                elements.chatMessages.addEventListener("scroll", function(){
                    const el = elements.chatMessages;
                    if (!el) return;
                    autoStick = (el.scrollHeight - el.scrollTop - el.clientHeight) < 80;
                });

                // è¾“å…¥æ¡†é”®ç›˜äº‹ä»¶
                elements.messageInput.addEventListener(
                    "keydown",
                    function (event) {
                        if (event.key === "Enter" && !event.shiftKey) {
                            event.preventDefault();
                            sendMessage();
                        }
                    },
                );

                // è¾“å…¥æ¡†äº‹ä»¶ - æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
                elements.messageInput.addEventListener(
                    "input",
                    updateSendButton,
                );

                // è‡ªåŠ¨è°ƒæ•´è¾“å…¥æ¡†é«˜åº¦
                elements.messageInput.addEventListener(
                    "input",
                    adjustInputHeight,
                );

                // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€
                updateSendButton();
            }

            // æ›´æ–°å‘é€æŒ‰é’®çŠ¶æ€
            function updateSendButton() {
                const hasContent =
                    elements.messageInput.value.trim().length > 0;
                elements.sendButton.disabled = !hasContent || isStreaming;
            }

            // è°ƒæ•´è¾“å…¥æ¡†é«˜åº¦
            function adjustInputHeight() {
                elements.messageInput.style.height = "auto";
                elements.messageInput.style.height =
                    elements.messageInput.scrollHeight + "px";
            }

            // åˆ‡æ¢ Think æ¨¡å¼
            function toggleThinkMode() {
                thinkMode = !thinkMode;
                localStorage.setItem("thinkMode", JSON.stringify(thinkMode));
                updateThinkToggleUI();
            }

            function updateThinkToggleUI() {
                if (!elements.thinkToggle) return;
                elements.thinkToggle.classList.toggle("active", thinkMode);
                elements.thinkToggle.setAttribute("aria-pressed", thinkMode ? "true" : "false");
                elements.thinkToggle.title = thinkMode ? "Think æ¨¡å¼ï¼šå¼€å¯" : "Think æ¨¡å¼ï¼šå…³é—­";
            }

            // å‘é€æ¶ˆæ¯
            async function sendMessage() {
                const message = elements.messageInput.value.trim();

                if (!message || isStreaming) {
                    return;
                }

                // æ·»åŠ ç”¨æˆ·æ¶ˆæ¯åˆ°ç•Œé¢
                addMessage(message, "user");

                // æ¸…ç©ºè¾“å…¥æ¡†
                elements.messageInput.value = "";
                adjustInputHeight();

                // è®¾ç½®æµå¼çŠ¶æ€
                isStreaming = true;
                updateSendButton();
                elements.typingIndicator.style.display = "flex";

                // ç«‹å³æ·»åŠ AIæ¶ˆæ¯å ä½ç¬¦
                addMessage("", "assistant", false, true);
                currentStreamingElement =
                    elements.chatMessages.lastElementChild;
                if (currentStreamingElement) {
                    currentStreamingElement.messageTextEl =
                        currentStreamingElement.querySelector(".message-text");
                    currentStreamingElement.timeEl =
                        currentStreamingElement.querySelector(".message-time");
                    if (currentStreamingElement.messageTextEl) {
                        currentStreamingElement.messageTextEl.setAttribute("data-raw-text", "");
                        currentStreamingElement.messageTextEl.setAttribute("data-stable-len", "0");
                        currentStreamingElement.messageTextEl.innerHTML =
                            '<div class="stable"></div><div class="tail"><span class="typing-cursor">â–Œ</span></div>';
                    }
                }

                try {
                    await sendChatMessage(message);
                } catch (error) {
                    addMessage(
                        "æŠ±æ­‰ï¼Œå‘é€æ¶ˆæ¯æ—¶å‡ºç°é”™è¯¯ï¼Œè¯·ç¨åé‡è¯•ã€‚",
                        "assistant",
                        true,
                    );
                } finally {
                    isStreaming = false;
                    updateSendButton();
                    elements.typingIndicator.style.display = "none";
                    currentStreamingElement = null;
                    elements.messageInput.focus();
                }
            }

            // å‘é€èŠå¤©æ¶ˆæ¯åˆ°æœåŠ¡å™¨
            async function sendChatMessage(message) {
                const requestData = {
                    message: message,
                    session_id: currentSessionId,
                    think: thinkMode,
                };

                try {
                    // å°è¯•æµå¼æ¥å£
                    const response = await fetch("/api/chat/stream", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                            Accept: "text/event-stream",
                            "Cache-Control": "no-cache",
                        },
                        body: JSON.stringify(requestData),
                    });

                    if (!response.ok) {
                        throw new Error(
                            `HTTP error! status: ${response.status}`,
                        );
                    }

                    // å¤„ç†æµå¼å“åº”
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = "";

                    while (true) {
                        const { done, value } = await reader.read();
                        if (done) break;

                        buffer += decoder.decode(value, { stream: true });

                        // å¤„ç†SSEæ•°æ®
                        const lines = buffer.split("\n");
                        buffer = lines.pop() || "";

                        for (const line of lines) {
                            if (line.trim() === "") continue;
                            if (line.startsWith("data: ")) {
                                try {
                                    const data = JSON.parse(line.slice(6));

                                    if (
                                        data.content &&
                                        currentStreamingElement &&
                                        currentStreamingElement.messageTextEl
                                    ) {
                                        // æ›¿æ¢å ä½ç¬¦æˆ–è¿½åŠ å†…å®¹
                                        // ç´¯ç§¯åŸå§‹æ–‡æœ¬ï¼Œæ¸²æŸ“ç”± requestAnimationFrame æ‰¹å¤„ç†
                                        const prevRaw = currentStreamingElement.messageTextEl.getAttribute("data-raw-text") || "";
                                        const nextRaw = prevRaw + data.content;
                                        currentStreamingElement.messageTextEl.setAttribute("data-raw-text", nextRaw);
                                        scheduleStreamRender();

                                        scrollToBottom();
                                    }

                                    if (data.session_id) {
                                        currentSessionId = data.session_id;
                                        localStorage.setItem(
                                            "chatSessionId",
                                            currentSessionId,
                                        );
                                    }

                                    if (data.done && currentStreamingElement) {
                                        if (currentStreamingElement.timeEl) {
                                            currentStreamingElement.timeEl.textContent =
                                                new Date().toLocaleTimeString(
                                                    "zh-CN",
                                                );
                                        }
                                        // æµç»“æŸï¼šå»é™¤å…‰æ ‡ï¼Œæ¸²æŸ“æœ€ç»ˆå†…å®¹å¹¶ä¸€æ¬¡æ€§é«˜äº®
                                        try {
                                            const raw = currentStreamingElement.messageTextEl?.getAttribute('data-raw-text') || '';
                                            currentStreamingElement.messageTextEl.innerHTML = DOMPurify.sanitize(marked.parse(raw));
                                            Prism.highlightAllUnder(currentStreamingElement.messageTextEl);
                                        } catch (e) {
                                            console.warn("Prism final highlight failed:", e);
                                        }
                                        scrollToBottom();
                                    }
                                } catch (e) {
                                    // é™é»˜å¤„ç†JSONè§£æé”™è¯¯
                                }
                            }
                        }
                    }
                } catch (error) {
                    // é™çº§åˆ°æ™®é€šæ¥å£
                    const response = await fetch("/api/chat", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify(requestData),
                    });

                    if (!response.ok) {
                        throw new Error(
                            `HTTP error! status: ${response.status}`,
                        );
                    }

                    const data = await response.json();
                    addMessage(data.reply, "assistant");

                    if (data.session_id) {
                        currentSessionId = data.session_id;
                        localStorage.setItem("chatSessionId", currentSessionId);
                    }
                }
            }

            // æ·»åŠ æ¶ˆæ¯åˆ°èŠå¤©ç•Œé¢
            function addMessage(
                text,
                sender,
                isError = false,
                isStreaming = false,
            ) {
                const messageDiv = document.createElement("div");
                messageDiv.className = `message ${sender}-message`;

                const avatarDiv = document.createElement("div");
                avatarDiv.className = "message-avatar";

                const avatar = document.createElement("div");
                avatar.className =
                    sender === "user"
                        ? "avatar user-avatar"
                        : "avatar ai-avatar";

                if (sender === "user") {
                    avatar.innerHTML = `
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
                            <circle cx="12" cy="7" r="4"/>
                        </svg>
                    `;
                } else {
                    avatar.innerHTML = `
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M12 2L2 7v10c0 5.55 3.84 10.74 9 12 5.16-1.26 9-6.45 9-12V7l-10-5z"/>
                            <path d="M9 12l2 2 4-4"/>
                        </svg>
                    `;
                }

                avatarDiv.appendChild(avatar);

                const contentDiv = document.createElement("div");
                contentDiv.className = "message-content";

                const textDiv = document.createElement("div");
                textDiv.className = "message-text";
                if (isError) {
                    textDiv.classList.add("error-message");
                    textDiv.textContent = text;
                } else if (sender === "assistant") {
                    // å¯¹äºAIæ¶ˆæ¯ï¼Œæ¸²æŸ“markdown
                    textDiv.innerHTML = DOMPurify.sanitize(marked.parse(text));

                    // é«˜äº®ä»£ç å—
                    setTimeout(() => {
                        Prism.highlightAllUnder(textDiv);
                    }, 0);
                } else {
                    // å¯¹äºç”¨æˆ·æ¶ˆæ¯ï¼Œä¿æŒçº¯æ–‡æœ¬
                    textDiv.textContent = text;
                }

                const timeDiv = document.createElement("div");
                timeDiv.className = "message-time";
                timeDiv.textContent = new Date().toLocaleTimeString("zh-CN");

                contentDiv.appendChild(textDiv);
                contentDiv.appendChild(timeDiv);

                messageDiv.appendChild(avatarDiv);
                messageDiv.appendChild(contentDiv);

                elements.chatMessages.appendChild(messageDiv);

                if (!isStreaming) {
                    scrollToBottom();
                }
            }

            // æ»šåŠ¨åˆ°åº•éƒ¨ï¼ˆèŠ‚æµ + å¹³æ»‘ + ä»…åœ¨æ¥è¿‘åº•éƒ¨æ—¶è·Ÿéšï¼‰
            let scrollTimeout;
            function isNearBottom(el) {
                if (!el) return false;
                return (el.scrollHeight - el.scrollTop - el.clientHeight) < 80;
            }
            function scrollToBottom(immediate = false) {
                const el = elements.chatMessages;
                if (!el) return;
                if (!immediate && !isNearBottom(el)) return; // ç”¨æˆ·ä¸åœ¨åº•éƒ¨åˆ™ä¸å¼ºåˆ¶è·Ÿéš
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    const top = el.scrollHeight;
                    if (el.scrollTo) {
                        el.scrollTo({ top, behavior: immediate ? "auto" : "smooth" });
                    } else {
                        el.scrollTop = top;
                    }
                }, immediate ? 0 : 80);
            }

            // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
            document.addEventListener("DOMContentLoaded", initializeChat);
        </script>
    </body>
</html>
