//! # Real-time WebSocket Client
//!
//! This module provides a complete implementation of the GLM-Realtime API client.
//! It handles WebSocket connections, event processing, and bidirectional communication
//! for real-time audio and video conversations.

use crate::client::error::ZaiError;
use crate::real_time::types::*;
use base64::Engine;
use futures::{SinkExt, StreamExt};
use serde_json;
use std::result::Result as StdResult;
use tokio_tungstenite::{connect_async, tungstenite::Message};
use url::Url;

pub type Result<T> = StdResult<T, ZaiError>;

/// Real-time client for WebSocket communication with GLM-Realtime API
pub struct RealtimeClient {
    api_key: String,
    event_handler: Option<Box<dyn EventHandler>>,
    ws_stream: Option<tokio_tungstenite::WebSocketStream<tokio_tungstenite::MaybeTlsStream<tokio::net::TcpStream>>>,
    is_connected: bool,
}

impl RealtimeClient {
    /// Create a new real-time client
    pub fn new(api_key: impl Into<String>) -> Self {
        Self {
            api_key: api_key.into(),
            event_handler: None,
            ws_stream: None,
            is_connected: false,
        }
    }

    /// Set the event handler for processing server events
    pub fn with_event_handler(mut self, event_handler: impl EventHandler + 'static) -> Self {
        self.event_handler = Some(Box::new(event_handler));
        self
    }

    /// Connect to the GLM-Realtime WebSocket API
    pub async fn connect<M>(&mut self, model: M, config: SessionConfig) -> Result<()>
    where
        M: crate::real_time::models::RealtimeModel,
    {
        let url = model.websocket_url();
        let request = tokio_tungstenite::tungstenite::http::Request::builder()
            .uri(&url)
            .header("Authorization", format!("Bearer {}", self.api_key))
            .header("Host", model.websocket_host())
            .header(
                "Sec-WebSocket-Key",
                tokio_tungstenite::tungstenite::handshake::client::generate_key(),
            )
            .header("Sec-WebSocket-Version", "13")
            .header("Connection", "Upgrade")
            .header("Upgrade", "websocket")
            .body(())
            .map_err(|e| ZaiError::Unknown {
                code: 0,
                message: format!("Failed to create WebSocket request: {}", e),
            })?;

        let (ws_stream, response) = connect_async(request)
            .await
            .map_err(|e| ZaiError::Unknown {
                code: 0,
                message: format!("Failed to connect to WebSocket: {}", e),
            })?;

        log::info!("WebSocket connected with response: {:?}", response);

        self.ws_stream = Some(ws_stream);
        self.is_connected = true;

        // Send session configuration
        self.send_session_update(config).await?;

        Ok(())
    }

    /// Send session configuration update
    pub async fn send_session_update(&mut self, config: SessionConfig) -> Result<()> {
        let event = ClientEvent::SessionUpdate(SessionUpdateEvent {
            base: BaseClientEvent {
                event_id: Some(generate_event_id()),
                client_timestamp: Some(get_current_timestamp()),
                event_type: "session.update".to_string(),
            },
            session: config,
        });

        self.send_event(&event).await
    }

    /// Send audio data to the server
    pub async fn send_audio(&mut self, audio_data: &[u8]) -> Result<()> {
        let audio_base64 = base64::engine::general_purpose::STANDARD.encode(audio_data);
        let event = ClientEvent::InputAudioBufferAppend(InputAudioBufferAppendEvent {
            base: BaseClientEvent {
                event_id: Some(generate_event_id()),
                client_timestamp: Some(get_current_timestamp()),
                event_type: "input_audio_buffer.append".to_string(),
            },
            audio: audio_base64,
        });

        self.send_event(&event).await
    }

    /// Send video frame to the server
    pub async fn send_video_frame(&mut self, video_frame: &[u8]) -> Result<()> {
        let video_base64 = base64::engine::general_purpose::STANDARD.encode(video_frame);
        let event = ClientEvent::InputAudioBufferAppendVideoFrame(InputAudioBufferAppendVideoFrameEvent {
            base: BaseClientEvent {
                event_id: Some(generate_event_id()),
                client_timestamp: Some(get_current_timestamp()),
                event_type: "input_audio_buffer.append_video_frame".to_string(),
            },
            video_frame: video_base64,
        });

        self.send_event(&event).await
    }

    /// Commit the audio buffer (for Client VAD mode)
    pub async fn commit_audio_buffer(&mut self) -> Result<()> {
        let event = ClientEvent::InputAudioBufferCommit(InputAudioBufferCommitEvent {
            base: BaseClientEvent {
                event_id: Some(generate_event_id()),
                client_timestamp: Some(get_current_timestamp()),
                event_type: "input_audio_buffer.commit".to_string(),
            },
        });

        self.send_event(&event).await
    }

    /// Clear the audio buffer
    pub async fn clear_audio_buffer(&mut self) -> Result<()> {
        let event = ClientEvent::InputAudioBufferClear(InputAudioBufferClearEvent {
            base: BaseClientEvent {
                event_id: Some(generate_event_id()),
                client_timestamp: Some(get_current_timestamp()),
                event_type: "input_audio_buffer.clear".to_string(),
            },
        });

        self.send_event(&event).await
    }

    /// Create a conversation item (text message or function call response)
    pub async fn create_conversation_item(&mut self, item: RealtimeConversationItem) -> Result<()> {
        let event = ClientEvent::ConversationItemCreate(ConversationItemCreateEvent {
            base: BaseClientEvent {
                event_id: Some(generate_event_id()),
                client_timestamp: Some(get_current_timestamp()),
                event_type: "conversation.item.create".to_string(),
            },
            item,
        });

        self.send_event(&event).await
    }

    /// Delete a conversation item
    pub async fn delete_conversation_item(&mut self, item_id: &str) -> Result<()> {
        let event = ClientEvent::ConversationItemDelete(ConversationItemDeleteEvent {
            base: BaseClientEvent {
                event_id: Some(generate_event_id()),
                client_timestamp: Some(get_current_timestamp()),
                event_type: "conversation.item.delete".to_string(),
            },
            item_id: item_id.to_string(),
        });

        self.send_event(&event).await
    }

    /// Create a response (for Client VAD mode)
    pub async fn create_response(&mut self) -> Result<()> {
        let event = ClientEvent::ResponseCreate(ResponseCreateEvent {
            base: BaseClientEvent {
                event_id: Some(generate_event_id()),
                client_timestamp: Some(get_current_timestamp()),
                event_type: "response.create".to_string(),
            },
        });

        self.send_event(&event).await
    }

    /// Cancel a response
    pub async fn cancel_response(&mut self) -> Result<()> {
        let event = ClientEvent::ResponseCancel(ResponseCancelEvent {
            base: BaseClientEvent {
                event_id: Some(generate_event_id()),
                client_timestamp: Some(get_current_timestamp()),
                event_type: "response.cancel".to_string(),
            },
        });

        self.send_event(&event).await
    }

    /// Send a client event to the server
    async fn send_event(&mut self, event: &ClientEvent) -> Result<()> {
        if let Some(ref stream) = self.ws_stream {
            let json = serde_json::to_string(event)
                .map_err(|e| ZaiError::Unknown {
                    code: 0,
                    message: format!("Failed to serialize event: {}", e),
                })?;

            let message = Message::Text(json);

            stream
                .send(message)
                .await
                .map_err(|e| ZaiError::Unknown {
                    code: 0,
                    message: format!("Failed to send WebSocket message: {}", e),
                })?;

            Ok(())
        } else {
            Err(ZaiError::Unknown {
                code: 0,
                message: "WebSocket not connected".to_string(),
            })
        }
    }

    /// Start listening for server events
    pub async fn listen_for_events(&mut self) -> Result<()> {
        if let Some(ref mut stream) = self.ws_stream {
            loop {
                match stream.next().await {
                    Some(Ok(message)) => {
                        match message {
                            Message::Text(text) => {
                                if let Err(e) = self.handle_server_message(&text).await {
                                    log::error!("Error handling server message: {}", e);
                                }
                            }
                            Message::Close(frame) => {
                                log::info!("WebSocket connection closed: {:?}", frame);
                                self.is_connected = false;
                                break;
                            }
                            _ => {
                                // Ignore other message types for now
                            }
                        }
                    }
                    Some(Err(e)) => {
                        log::error!("WebSocket error: {}", e);
                        self.is_connected = false;
                        break;
                    }
                    None => {
                        log::info!("WebSocket stream ended");
                        self.is_connected = false;
                        break;
                    }
                }
            }
        }

        Ok(())
    }

    /// Handle incoming server message
    async fn handle_server_message(&mut self, text: &str) -> Result<()> {
        // Try to parse as a known server event first
        if let Ok(event) = serde_json::from_str::<ServerEvent>(text) {
            self.handle_server_event(event).await;
            return Ok(());
        }

        // If parsing as ServerEvent fails, try to parse as JSON and handle as unknown event
        if let Ok(json_value) = serde_json::from_str::<serde_json::Value>(text) {
            if let Some(ref mut handler) = self.event_handler {
                handler.on_unknown_event(json_value);
            }
        }

        Ok(())
    }

    /// Handle parsed server events
    async fn handle_server_event(&mut self, event: ServerEvent) {
        if let Some(ref mut handler) = self.event_handler {
            match event {
                ServerEvent::Error(event) => handler.on_error(event),
                ServerEvent::SessionCreated(event) => handler.on_session_created(event),
                ServerEvent::SessionUpdated(event) => handler.on_session_updated(event),
                ServerEvent::ResponseTextDelta(event) => handler.on_response_text_delta(event),
                ServerEvent::ResponseTextDone(event) => handler.on_response_text_done(event),
                ServerEvent::ResponseAudioDelta(event) => handler.on_response_audio_delta(event),
                ServerEvent::ResponseAudioDone(event) => handler.on_response_audio_done(event),
                ServerEvent::ResponseDone(event) => handler.on_response_done(event),
                ServerEvent::Heartbeat(event) => handler.on_heartbeat(event),
                // TODO: Add handlers for other server events as needed
                _ => {
                    // Convert to JSON for unknown events
                    if let Ok(json) = serde_json::to_value(&event) {
                        if let Some(ref mut handler) = self.event_handler {
                            handler.on_unknown_event(json);
                        }
                    }
                }
            }
        }
    }

    /// Check if the client is connected
    pub fn is_connected(&self) -> bool {
        self.is_connected
    }

    /// Close the WebSocket connection
    pub async fn close(&mut self) -> Result<()> {
        if let Some(ref mut stream) = self.ws_stream {
            let close_message = Message::Close(None);
            stream.send(close_message).await.ok(); // Ignore errors on close
            self.is_connected = false;
        }
        Ok(())
    }
}

impl Drop for RealtimeClient {
    fn drop(&mut self) {
        // Clean up WebSocket connection if still open
        if self.is_connected {
            let _ = tokio::runtime::Handle::current().block_on(self.close());
        }
    }
}

/// Generate a unique event ID
fn generate_event_id() -> String {
    uuid::Uuid::new_v4().to_string()
}

/// Get the current timestamp in milliseconds
fn get_current_timestamp() -> u64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis() as u64
}
```

```path/to/filename.ext
code goes here
