//! Core data types for GLM-Realtime API.
//!
//! This module defines the fundamental data structures used throughout the
//! real-time audio and video communication API.

use serde::{Deserialize, Serialize};
use validator::Validate;

/// Represents a conversation item in the real-time dialogue.
///
/// This structure defines different types of items that can appear in a conversation,
/// including text messages, audio content, function calls, and function call results.
#[derive(Clone, Debug, Serialize, Deserialize, Validate, Default)]
#[serde(default)]
pub struct RealtimeConversationItem {
    /// Unique identifier for the item.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Type of the item.
    #[serde(rename = "type")]
    pub item_type: ItemType,

    /// Object type, always "realtime.item".
    pub object: String,

    /// Status of the item.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<ItemStatus>,

    /// Role of the message sender (for message items).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub role: Option<Role>,

    /// Content of the item.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<Vec<ContentPart>>,

    /// Function call name (for function_call items).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Function call arguments (for function_call items).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option<String>,

    /// Function call output (for function_call_output items).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output: Option<String>,
}

// Implement getter methods for RealtimeConversationItem
impl RealtimeConversationItem {
    /// Get the id
    pub fn get_id(&self) -> Option<&String> {
        self.id.as_ref()
    }

    /// Get the item_type
    pub fn get_item_type(&self) -> &ItemType {
        &self.item_type
    }

    /// Get the object
    pub fn get_object(&self) -> &str {
        &self.object
    }

    /// Get the status
    pub fn get_status(&self) -> Option<&ItemStatus> {
        self.status.as_ref()
    }

    /// Get the role
    pub fn get_role(&self) -> Option<&Role> {
        self.role.as_ref()
    }

    /// Get the content
    pub fn get_content(&self) -> Option<&Vec<ContentPart>> {
        self.content.as_ref()
    }

    /// Get the name
    pub fn get_name(&self) -> Option<&String> {
        self.name.as_ref()
    }

    /// Get the arguments
    pub fn get_arguments(&self) -> Option<&String> {
        self.arguments.as_ref()
    }

    /// Get the output
    pub fn get_output(&self) -> Option<&String> {
        self.output.as_ref()
    }

    /// Serialize to JSON string
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string(self)
    }

    /// Deserialize from JSON string
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }
}

/// Type of a conversation item.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
pub enum ItemType {
    /// Regular message with text or audio content.
    #[default]
    Message,
    /// Function call request.
    FunctionCall,
    /// Result of a function call.
    FunctionCallOutput,
}

/// Status of a conversation item.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum ItemStatus {
    /// Item is fully processed.
    Completed,
    /// Item is partially processed or incomplete.
    Incomplete,
}

/// Role of a message sender.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "lowercase")]
pub enum Role {
    /// User message.
    User,
    /// Assistant (AI) message.
    Assistant,
    /// System message.
    System,
}

/// Represents a part of the content in a conversation item.
///
/// Content can be of different types depending on the input and output modalities:
/// - Text: Plain text content for both input and output
/// - InputAudio: Base64-encoded audio data uploaded by the user
/// - InputText: Text input from the user
/// - Audio: Base64-encoded audio data generated by the model
/// - Video: Base64-encoded video frame data (JPG format) uploaded by the user
///
#[derive(Clone, Debug, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ContentPart {
    /// Text content.
    /// Used for both input and output messages containing plain text.
    Text {
        /// The actual text content.
        #[serde(skip_serializing_if = "Option::is_none")]
        text: Option<String>,
    },
    /// Input audio content.
    /// Used for audio data uploaded by the user in messages with role "user".
    InputAudio {
        /// Base64 encoded audio data.
        #[serde(skip_serializing_if = "Option::is_none")]
        audio: Option<String>,
        /// Transcription of the audio.
        /// This field is populated after speech-to-text processing of the audio.
        #[serde(skip_serializing_if = "Option::is_none")]
        transcript: Option<String>,
    },
    /// Input text content.
    /// Used for text input from the user, typically for function call results.
    InputText {
        /// The actual text content.
        #[serde(skip_serializing_if = "Option::is_none")]
        text: Option<String>,
    },
    /// Output audio content.
    /// Used for audio data generated by the model in responses.
    Audio {
        /// Base64 encoded audio data.
        /// Format is PCM16 with 24kHz sample rate, single channel, 16-bit depth.
        #[serde(skip_serializing_if = "Option::is_none")]
        audio: Option<String>,
    },
    /// Video frame content.
    /// Used for video frames uploaded by the user in video mode.
    Video {
        /// Base64 encoded video frame data.
        /// Must be in JPG format. Recommended to upload at 1-2 fps for video calls.
        #[serde(skip_serializing_if = "Option::is_none")]
        video_frame: Option<String>,
    },
}

impl Default for ContentPart {
    fn default() -> Self {
        ContentPart::Text { text: None }
    }
}

// Implement getter methods for ContentPart
impl ContentPart {
    /// Get the text if this is a Text variant
    pub fn get_text(&self) -> Option<&String> {
        match self {
            ContentPart::Text { text } => text.as_ref(),
            _ => None,
        }
    }

    /// Get the audio if this is an InputAudio variant
    pub fn get_input_audio(&self) -> Option<&String> {
        match self {
            ContentPart::InputAudio { audio, .. } => audio.as_ref(),
            _ => None,
        }
    }

    /// Get the transcript if this is an InputAudio variant
    pub fn get_transcript(&self) -> Option<&String> {
        match self {
            ContentPart::InputAudio { transcript, .. } => transcript.as_ref(),
            _ => None,
        }
    }

    /// Get the text if this is an InputText variant
    pub fn get_input_text(&self) -> Option<&String> {
        match self {
            ContentPart::InputText { text } => text.as_ref(),
            _ => None,
        }
    }

    /// Get the audio if this is an Audio variant
    pub fn get_audio(&self) -> Option<&String> {
        match self {
            ContentPart::Audio { audio } => audio.as_ref(),
            _ => None,
        }
    }

    /// Get the video_frame if this is a Video variant
    pub fn get_video_frame(&self) -> Option<&String> {
        match self {
            ContentPart::Video { video_frame } => video_frame.as_ref(),
            _ => None,
        }
    }

    /// Serialize to JSON string
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string(self)
    }

    /// Deserialize from JSON string
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }
}

/// Represents a server response object.
#[derive(Clone, Debug, Serialize, Deserialize, Validate, Default)]
#[serde(default)]
pub struct RealtimeResponse {
    /// Unique identifier for the response.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,

    /// Object type, always "realtime.response".
    pub object: String,

    /// Status of the response.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<ResponseStatus>,

    /// Usage statistics for the response.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub usage: Option<Usage>,
}

// Implement getter methods for RealtimeResponse
impl RealtimeResponse {
    /// Get the id
    pub fn get_id(&self) -> Option<&String> {
        self.id.as_ref()
    }

    /// Get the object
    pub fn get_object(&self) -> &str {
        &self.object
    }

    /// Get the status
    pub fn get_status(&self) -> Option<&ResponseStatus> {
        self.status.as_ref()
    }

    /// Get the usage
    pub fn get_usage(&self) -> Option<&Usage> {
        self.usage.as_ref()
    }

    /// Serialize to JSON string
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string(self)
    }

    /// Deserialize from JSON string
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }
}

/// Status of a response.
#[derive(Clone, Debug, Serialize, Deserialize, PartialEq, Eq, Default)]
#[serde(rename_all = "snake_case")]
pub enum ResponseStatus {
    /// Response is in progress.
    #[default]
    InProgress,
    /// Response is completed successfully.
    Completed,
    /// Response was cancelled.
    Cancelled,
}

/// Token usage information for a response.
#[derive(Clone, Debug, Serialize, Deserialize, Validate, Default)]
#[serde(default)]
pub struct Usage {
    /// Total tokens used.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub total_tokens: Option<u32>,

    /// Input tokens used.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input_tokens: Option<u32>,

    /// Output tokens used.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output_tokens: Option<u32>,

    /// Details about input token usage.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input_token_details: Option<InputTokenDetails>,

    /// Details about output token usage.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output_token_details: Option<OutputTokenDetails>,
}

// Implement getter methods for Usage
impl Usage {
    /// Get the total_tokens
    pub fn get_total_tokens(&self) -> Option<u32> {
        self.total_tokens
    }

    /// Get the input_tokens
    pub fn get_input_tokens(&self) -> Option<u32> {
        self.input_tokens
    }

    /// Get the output_tokens
    pub fn get_output_tokens(&self) -> Option<u32> {
        self.output_tokens
    }

    /// Get the input_token_details
    pub fn get_input_token_details(&self) -> Option<&InputTokenDetails> {
        self.input_token_details.as_ref()
    }

    /// Get the output_token_details
    pub fn get_output_token_details(&self) -> Option<&OutputTokenDetails> {
        self.output_token_details.as_ref()
    }

    /// Serialize to JSON string
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string(self)
    }

    /// Deserialize from JSON string
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }
}

/// Details about input token usage.
#[derive(Clone, Debug, Serialize, Deserialize, Validate, Default)]
#[serde(default)]
pub struct InputTokenDetails {
    /// Number of cached tokens used.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cached_tokens: Option<u32>,

    /// Number of text tokens used.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text_tokens: Option<u32>,

    /// Number of audio tokens used.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audio_tokens: Option<u32>,
}

// Implement getter methods for OutputTokenDetails
impl OutputTokenDetails {
    /// Get the text_tokens
    pub fn get_text_tokens(&self) -> Option<u32> {
        self.text_tokens
    }

    /// Get the audio_tokens
    pub fn get_audio_tokens(&self) -> Option<u32> {
        self.audio_tokens
    }

    /// Serialize to JSON string
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string(self)
    }

    /// Deserialize from JSON string
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }
}

// Implement getter methods for InputTokenDetails
impl InputTokenDetails {
    /// Get the cached_tokens
    pub fn get_cached_tokens(&self) -> Option<u32> {
        self.cached_tokens
    }

    /// Get the text_tokens
    pub fn get_text_tokens(&self) -> Option<u32> {
        self.text_tokens
    }

    /// Get the audio_tokens
    pub fn get_audio_tokens(&self) -> Option<u32> {
        self.audio_tokens
    }

    /// Serialize to JSON string
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string(self)
    }

    /// Deserialize from JSON string
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }
}

/// Details about output token usage.
#[derive(Clone, Debug, Serialize, Deserialize, Validate, Default)]
#[serde(default)]
pub struct OutputTokenDetails {
    /// Number of text tokens used.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub text_tokens: Option<u32>,

    /// Number of audio tokens used.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub audio_tokens: Option<u32>,
}

/// Error information for error events.
///
/// Errors can be either client-side or server-side issues. Most errors are recoverable
/// and the session will remain open. Common error types include:
///
/// ### Client Errors
/// - `invalid_request_error`: Invalid request format or missing required fields
/// - `authentication_error`: Invalid or missing authentication
/// - `permission_error`: Insufficient permissions for the requested operation
///
/// ### Server Errors
/// - `api_error`: Internal server error
/// - `rate_limit_error`: Rate limit exceeded
/// - `model_unavailable`: Requested model is temporarily unavailable
///
/// ### Media-specific Errors
/// - `asr_no_result`: Audio speech recognition failed to produce results
/// - `video_model_query_error`: Video model query failed
/// - `invalid_audio_format`: Unsupported audio format
/// - `invalid_video_format`: Unsupported video format
///
#[derive(Clone, Debug, Serialize, Deserialize, Validate, Default)]
#[serde(default)]
pub struct ErrorInfo {
    /// Type of the error.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#type: Option<String>,

    /// Error code.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub code: Option<String>,

    /// Error message.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}

// Implement getter methods for ErrorInfo
impl ErrorInfo {
    /// Get the error type
    pub fn get_type(&self) -> Option<&String> {
        self.r#type.as_ref()
    }

    /// Get the error code
    pub fn get_code(&self) -> Option<&String> {
        self.code.as_ref()
    }

    /// Get the error message
    pub fn get_message(&self) -> Option<&String> {
        self.message.as_ref()
    }

    /// Serialize to JSON string
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string(self)
    }

    /// Deserialize from JSON string
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }
}

/// Rate limit information.
#[derive(Clone, Debug, Serialize, Deserialize, Validate, Default)]
#[serde(default)]
pub struct RateLimit {
    /// Name of the rate limit (e.g., "requests").
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// Maximum allowed requests for the current time window.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit: Option<u32>,

    /// Remaining requests before hitting the limit.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remaining: Option<u32>,

    /// Seconds until rate limit resets.
    /// Represents the time remaining before the rate limit window resets.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub reset_seconds: Option<f32>,
}

// Implement getter methods for RateLimit
impl RateLimit {
    /// Get the name
    pub fn get_name(&self) -> Option<&String> {
        self.name.as_ref()
    }

    /// Get the limit
    pub fn get_limit(&self) -> Option<u32> {
        self.limit
    }

    /// Get the remaining
    pub fn get_remaining(&self) -> Option<u32> {
        self.remaining
    }

    /// Get the reset_seconds
    pub fn get_reset_seconds(&self) -> Option<f32> {
        self.reset_seconds
    }

    /// Serialize to JSON string
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string(self)
    }

    /// Deserialize from JSON string
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json)
    }
}

// Test module for types
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_realtime_conversation_item_serialization() {
        let mut item = RealtimeConversationItem::default();
        item.id = Some("item-123".to_string());
        item.item_type = ItemType::Message;
        item.object = "realtime.item".to_string();
        item.status = Some(ItemStatus::Completed);
        item.role = Some(Role::User);

        let json = item.to_json().unwrap();
        let deserialized_item: RealtimeConversationItem =
            RealtimeConversationItem::from_json(&json).unwrap();

        assert_eq!(item.get_id(), deserialized_item.get_id());
        assert_eq!(item.get_item_type(), deserialized_item.get_item_type());
        assert_eq!(item.get_object(), deserialized_item.get_object());
        assert_eq!(item.get_status(), deserialized_item.get_status());
        assert_eq!(item.get_role(), deserialized_item.get_role());
    }

    #[test]
    fn test_content_part_serialization() {
        let content = ContentPart::Text {
            text: Some("Hello, world!".to_string()),
        };

        let json = content.to_json().unwrap();
        let deserialized_content: ContentPart = ContentPart::from_json(&json).unwrap();

        assert_eq!(content.get_text(), deserialized_content.get_text());
    }

    #[test]
    fn test_realtime_response_serialization() {
        let mut response = RealtimeResponse::default();
        response.id = Some("resp-123".to_string());
        response.object = "realtime.response".to_string();
        response.status = Some(ResponseStatus::Completed);

        let json = response.to_json().unwrap();
        let deserialized_response: RealtimeResponse = RealtimeResponse::from_json(&json).unwrap();

        assert_eq!(response.get_id(), deserialized_response.get_id());
        assert_eq!(response.get_object(), deserialized_response.get_object());
        assert_eq!(response.get_status(), deserialized_response.get_status());
    }

    #[test]
    fn test_usage_serialization() {
        let mut usage = Usage::default();
        usage.total_tokens = Some(100);
        usage.input_tokens = Some(60);
        usage.output_tokens = Some(40);

        let json = usage.to_json().unwrap();
        let deserialized_usage: Usage = Usage::from_json(&json).unwrap();

        assert_eq!(
            usage.get_total_tokens(),
            deserialized_usage.get_total_tokens()
        );
        assert_eq!(
            usage.get_input_tokens(),
            deserialized_usage.get_input_tokens()
        );
        assert_eq!(
            usage.get_output_tokens(),
            deserialized_usage.get_output_tokens()
        );
    }
}
